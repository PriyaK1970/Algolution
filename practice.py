# -*- coding: utf-8 -*-
"""Practice

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pic2x_OsYqo6228hftFi2MK4DnyXYJAr
"""

# heap sort
def heapify(arr, n, i, heap_type):
    largest = i
    left = 2 * i + 1
    if heap_type == 'max':
        if left < n and arr[left] > arr[largest]:
            largest = left
        if 2 * i + 2 < n and arr[2 * i + 2] > arr[largest]:
            largest = 2 * i + 2
    elif heap_type == 'min':
        if left < n and arr[left] < arr[largest]:
            largest = left
        if 2 * i + 2 < n and arr[2 * i + 2] < arr[largest]:
            largest = 2 * i + 2
        if largest != i:
            arr[i], arr[largest] = arr[largest], arr[i]
            heapify(arr, n, largest, heap_type)

def heap_sort(arr, heap_type):
    n = len(arr)
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i, heap_type)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0, heap_type)
    return arr

A = list(map(int, input("Enter the elements of the array: ").split()))
Max_heap = heap_sort(A,'max')
Min_heap = heap_sort(A,'min')
print("Max heap: ",Max_heap)
print("Min heap: ",Min_heap)

n = input("Enter a string: ")
print(len(n))

q = input("Enter a string: ")
print(q[::-1])

def reversal(q):
  sum = 0
  while(q!=0):
    w = q % 10
    sum = sum * 10 + w
    q = q//10
  return sum
def palindrome(e):
  if isinstance (e,str):
    r = e
    if(e[::-1] == r[::1]):
      print("Input is Palindrome")
    else:
      print("Input is not Palindrome")
  else:
    y = e
    t = reversal(e)
    if(t == y):
      print("Number is Palindrome")
    else:
      print("Number is not Palindrome")
n = int(input("Enter 1 if input is string or Enter 2 if input is number: "))
if(n == 1):
  u = input("Enter string: ")
  palindrome(u)
else:
  i = int(input("Enter number: "))
  palindrome(i)

def anagram(s,prefix =" "):
  if isinstance(s,str):
    if len(s) <= 1:
      print(prefix + s)
    else:
      for i in range(len(s)):
        b = s[:i] + s[i+1:]
        anagram(b,prefix + s[i])
  else:
    v = str(s)
    if len(v) <= 1:
      print(prefix + v)
    else:
      for i in range(len(v)):
        c = v[:i] + v[i+1:]
        anagram(int(c),prefix + v[i])
n = int(input("Enter 1 if input is string or Enter 2 if input is number: "))
if(n == 1):
  m = input("Enter String: ")
  anagram(m)
else:
  m = int(input("Enter number: "))
  anagram(m)

def linear_search(l,v):
  f = 0
  for i in l:
    if v == l[i]:
      f = 1
      break
  if(f == 1):
    print("Value is found at: ",i)
  else:
    print("Value is not found")
n = int(input("Enter number of values: "))
q = []
for i in range(1,n+1):
  element = int(input("Enter element: "))
  q.append(element)
w = int(input("Enter the value you want to search: "))
linear_search(q,w)

def binary_search(l,v):
  start = 0
  end =len(l)
  while(start != end):
    mid = (start + end)/2
    if(mid == v):
      print("Value is found at: ",mid)
      break
    elif(mid<v):
      start = mid + 1
    else:
      end = mid  - 1
n = int(input("Enter number of values: "))
e =[]
for i in range(1,n+1):
  element = int(input("Enter element: "))
  e.append(element)
r = int(input("Enter value you want to search: "))
binary_search(e,r)

def bubble_sort(l):
  n = len(l)
  for i in range(n):
    for j in range(0,n-i-1):
      if l[j] > l[j+1]:
        l[j],l[j+1] = l[j+1],l[j]
p = [3,6,7,8,5]
bubble_sort(p)
print(p)

def selection_sort(l):
  n = len(l)
  for i in range(n):
    min = i
    for j in range(i+1,n):
      if l[j] < l[min]:
        min = j
    l[i],l[min] = l[min],l[i]
o = [6,8,3,5,7,9]
selection_sort(o)
print(o)

def insertion_sort(l):
  n = len(l)
  for i in range(1,n):
    key = l[i]
    j = i-1
    while j >= 0 and key < l[j]:
      l[j+1] = l[j]
      j = j-1
    l[j + 1] = key
t = [3,5,6,1,7,9,2]
insertion_sort(t)
print(t)

def merge_sort(l):
  n = len(l)
  if n > 1:
    mid = n//2
    left = l[:mid]
    right = l[mid:]

    merge_sort(left)
    merge_sort(right)

    i = j = k = 0
    while i<len(left) and j<len(right):
      if left[i] < right[j]:
        l[k] = left[i]
        i = i+1
      else:
        l[k] = right[j]
        j = j+1
      k = k+1
    while i < len(left):
      l[k] = left[i]
      i = i+1
      k = k+1
    while j < len(right):
      l[k] = right[j]
      j = j+1
      k = k+1
a = [4,3,6,8,9,1,2,5]
merge_sort(a)
print(a)

# Quick sort
def partition(l,low,high):
  pivot = l[high]
  i = low - 1
  for j in range(low,high):
    if l[j] <= pivot:
      i = i+1
      l[i],l[j] = l[j],l[i]
  l[i+1],l[high] = l[high],l[i+1]
  return i+1
def quick_sort(l,low,high):
  if low < high:
    p = partition(l,low,high)
    quick_sort(l,low,p-1)
    quick_sort(l,p+1,high)
x = [7,5,3,2,9,8]
n = len(x)
quick_sort(x,0,n-1)
print(x)

#Intersection of two arrays
import numpy as np
def intersection(l1,l2,l3):
  for i in range(len(l1)):
    for j in range(len(l2)):
      if(l1[i] == l2[j]):
        l3.append(l1[i])
  return l3
n = int(input("Enter number of elements you want to insert in array: "))
l1 = []
l2 = []
l3 = []
print("For 1st array")
for i in range(1,n+1):
  elements = int(input("Enter elements: "))
  l1.append(elements)
print("For 2nd array")
for i in range(1,n+1):
  elements = int(input("Enter elements: "))
  l2.append(elements)
l1.sort()
l2.sort()
intersection(l1,l2,l3)
print("Intersection of two given arrays :",l3)

#Array puzzle
def puzzle(l1,l2):
  for i in range(len(l1)):
    p = 1
    for j in range(len(l1)):
      if i!=j:
        p = p*l1[j]
    l2.append(p)
  return l2
n = int(input("Enter number of elements you want to insert in array: "))
l1 = []
l2 = []
for i in range(1,n+1):
  elements = int(input("Enter elements: "))
  l1.append(elements)
puzzle(l1,l2)
print(l2)

def subarray(l,start,end):
  while start>len(l)-1 and l[start]<=l[start+1]:
    start = start + 1
  while end>0 and l[end]>=l[end - 1]:
    end = end - 1
  subarray_min = min(l[start:end + 1])
  subarray_max = max(l[start:end + 1])
  for i in range(start):
    if l[i] > subarray_min:
      start = i
      break
  for i in range(len(l)-1,end,-1):
    if l[i] < subarray_max:
      end = i
      break
  return start,end
n = int(input("Enter number of elements you want to insert in an array: "))
l1 = []
for i in range(1,n+1):
  elements = int(input("Enter elements: "))
  l1.append(elements)
start = 0
end = len(l1) - 1
subarray(l1,start,end)

# Sliding window
from collections import deque
def sliding_window(l,k):
  n = len(l)
  result = []
  window = deque()
  for i in range(n):
    while window and window[0]<i-k+1:
      window.popleft()
    while window and l[i]>=l[window[-1]]:
      window.pop()
    window.append(i)
    if i>=k-1:
      result.append(l[window[0]])
  return result
n = int(input("Enter the number of elements you want to insert in an array: "))
l = []
for i in range(1,n+1):
  elements = int(input("Enter elements: "))
  l.append(elements)
k = int(input("Enter the value of window: "))
o = []
o = sliding_window(l,k)
print(o)

#3 sum problem
def triplet(l,sum):
  l.sort()
  n = len(l)
  for i in range(n-2):
    left = i+1
    right = n-1
    while left<right:
      current = l[i] + l[left] + l[right]
      if current == sum:
       return(l[i],l[left],l[right])
      elif current < sum:
        left = left + 1
      else:
        right = right - 1
  return False

n = int(input("Enter the number of elements you want to insert in an array: "))
l = []
for i in range(1,n+1):
  elements = int(input("Enter elements: "))
  l.append(elements)
sum = int(input("Enter the sum: "))
o = []
o = triplet(l,sum)
if o:
  print(o)
else:
  print("No triplet")

#Frequency

n = int(input("Enter the number of elements you want to insert in an array: "))
l = []
for i in range(1,n+1):
  elements = int(input("Enter elements: "))
  l.append(elements)

#knapsack fractional problem
def knapsack_fractional(items,capacity):
  items.sort(key=lambda x:x[2]/x[1],reverse = True)
  max = 0
  fraction = [0]*len(items)

  for i,(objects,weight,profit) in enumerate(items):
    if weight<=capacity:
      fraction[i] = 1
      max = max + profit
      capacity = capacity - weight
    else:
      fraction[i] = capacity/weight
      max = max + profit * capacity/weight
      break
  return max,fraction
no = int(input("Number of items: "))
items = []
for i in range(no):
  objects = int(input("Enter object: {}".format(i+1)))
  profit = int(input("Its associated profit: {}".format(i+1)))
  weight = int(input("Its weight: {}".format(i+1)))
  items.append((objects,weight,profit))
capacity = int(input("Enter capacity: "))
max , fraction = knapsack_fractional(items,capacity)
print("Total Profit",max)
print("Fractions of items",fraction)

#job_sequencing
def job_sequencing(jobs):
   jobs.sort(key=lambda x:x[2]/x[1],reverse = True)
   max_deadline = max(jobs,key=lambda x:x[1])[1]
   time_slots = [-1]*max_deadline

   total_profit = 0
   job_sequence = []
   for job in jobs:
    deadline = job[1]
    for i in range(deadline-1,-1,-1):
      if time_slots[i] == -1:
        time_slots[i] = 0
        total_profit = total_profit + job[2]
        job_sequence.append(job[0])
        break
   return total_profit,job_sequence
no = int(input("Number of jobs: "))
jobs = []
for i in range(no):
  job_id = (input("Enter job_id: {}".format(i+1)))
  deadline = int(input("Enter deadline: {}".format(i+1)))
  profit = int(input("Its associated profit: {}".format(i+1)))
  jobs.append((job_id,deadline,profit))
profit,sequence = job_sequencing(jobs)
print("Maximum profit: ",profit)
print("Job sequence: ",sequence)

#subsequence
def is_subsequence(s1, s2):
    i, j = 0, 0
    while i < len(s1) and j < len(s2):
        if s1[i] == s2[j]:
            j += 1
        i += 1
    return j == len(s2)
n = input("Enter the first string: ")
m = input("Enter the second string: ")
if is_subsequence(n,m):
  print("Yes")
else:
  print("No")

#common subsequence
def all_common_subsequences(s1, s2):
    if not s1 or not s2:
        return [""]

    if s1[0] == s2[0]:
        rest = all_common_subsequences(s1[1:], s2[1:])
        return [s1[0] + subseq for subseq in rest] + rest
    else:
        result = []
        result += all_common_subsequences(s1[1:], s2)
        result += all_common_subsequences(s1, s2[1:])
        return result
n = input(input("Enter the first string: "))
m = input(input("Enter the second string: "))
common_subsequences = all_common_subsequences(n, m)
print(common_subsequences)

# largest common subsequence
def longest_common_subsequence(s1, s2):
    m = len(s1)
    n = len(s2)

    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i - 1] == s2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])

    lcs = ""
    i, j = m, n
    while i > 0 and j > 0:
        if s1[i - 1] == s2[j - 1]:
            lcs = s1[i - 1] + lcs
            i -= 1
            j -= 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i -= 1
        else:
            j -= 1

    return lcs
n = (input("Enter the first string: "))
m = (input("Enter the second string: "))
subsequences = longest_common_subsequence(n,m)
print(subsequences)

#floyd warshal algorithm
def solution(dlist,v):
  print("Shortest path between the plain of vertices: ")
  for i in range(v):
    for j in range(v):
      if dlist[i][j] == float("inf"):
        print("INF",end=" ")
      else:
        print(dlist[i][j],end=" ")
    print()
def floyd_warshal(graph,v):
  dlist = list(map(lambda i:list(map(lambda j:j,i)),graph))
  for k in range(v):
    for i in range(v):
      for j in range(v):
        dlist[i][j] = min(dlist[i][j],dlist[i][k]+dlist[k][j])
  solution(dlist,v)
v = int(input("Enter the number of vertices: "))
graph = []
print("Enter the adjacency matrix for the graph: ")
for i in range(v):
  row = list(map(float,input().split()))
  graph.append(row)
floyd_warshal(graph,v)

#number of good pairs
def good_pairs(nums):
  count_dict = {}
  good_pairs = 0
  for n in nums:
    if n in count_dict:
      count_dict[n] = count_dict[n] + 1
    else:
      count_dict[n] = 1
    for key in count_dict:
      count = count_dict[key]
      if count > 1:
        good_pairs += count * (count - 1) // 2
  return good_pairs
nums = list(map(int,input("Enter the array of integers separated by spaces: ").split()))
o = good_pairs(nums)
print(o)

#check if prime
n = int(input("Enter a number: "))
i = 2
is_prime = True
if n<2:
  is_prime = False
while i*i<=n:
  if n%i == 0:
    is_prime = False
    break
  i = i+1
if is_prime:
  print("Prime")
else:
  print("Not Prime")

n = int(input("Enter a number: "))
is_prime = True
if n<2:
  is_prime = False
i = n
while i>2:
  if n%i == 0 and i!=n:
    is_prime = False
    break
  i = i-1
if is_prime:
  print("Prime")
else:
  print("Not Prime")

n = int(input("Enter a number: "))
is_prime = True
if n<2:
  is_prime = False
i = 2
while True:
  if n%i == 0:
    is_prime = False
    break
  i = i+1
  if i*i>n:
    break
if is_prime:
  print("Prime")
else:
  print("Not Prime")

def recursive(n,i):
  if i==1:
    return True
  if n<2:
    return ("Input is less than 2 and Prime")
  if n%2 == 0:
    return False
  else:
    return recursive(n,i-1)

n = int(input("Enter a number: "))
result = recursive(n,int(n/2))
if result:
   print("Prime")
else:
   print("Not Prime")

#find out maximum number from 1-D array
n =[]
num = int(input("Enter the number of elements you want to insert in an array: "))
for j in range(num):
  elements = int(input("Enter elements: "))
  n.append(elements)
max_num = n[0]
i = 0
while i<len(n):
  if n[i]>max_num:
    max_num = n[i]
  i = i+1
print(max_num)

n =[]
num = int(input("Enter the number of elements you want to insert in an array: "))
for j in range(num):
  elements = int(input("Enter elements: "))
  n.append(elements)
max_num = n[-1]
i = len(n)-2
while i>=0:
  if n[i]>max_num:
    max_num = n[i]
  i = i-1
print(max_num)

n =[]
num = int(input("Enter the number of elements you want to insert in an array: "))
for j in range(num):
  elements = int(input("Enter elements: "))
  n.append(elements)
max_num = n[0]
i = 0
while True:
  if n[i]>max_num:
    max_num = n[i]
  i = i+1
  if i==len(n):
    break
print(max_num)

def max(l,num):
  if num == 1:
    return l[0]
  max_number = max(l,num-1)
  return l[num-1] if l[num-1] > max_number else max_number
n =[]
num = int(input("Enter the number of elements you want to insert in an array: "))
for j in range(num):
  elements = int(input("Enter elements: "))
  n.append(elements)
print(max(n,num))

# Iterative Binary Search
def iterative_binary_search(arr, target):
  low = 0
  high = len(arr) - 1

  while low <= high:
    mid = (low + high) // 2

    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        low = mid + 1
    else:
        high = mid - 1

  return -1
arr = list(map(int, input("Enter a sorted list of elements separated by spaces: ").split()))
target = int(input("Enter the target element to search for: "))
result = iterative_binary_search(arr, target)
if result != -1:
    print(f"Element found at index {result}")
else:
    print("Element not found")

# Recursive Binary Search
def recursive_binary_search(arr, target, low, high):
    if low > high:
        return -1
    mid = (low + high) // 2
    if arr[mid] == target:
        return mid
    elif arr[mid] < target:
        return recursive_binary_search(arr, target, mid + 1, high)
    else:
        return recursive_binary_search(arr, target, low, mid - 1)
arr = list(map(int, input("Enter a sorted list of elements separated by spaces: ").split()))
target = int(input("Enter the target element to search for: "))
result = recursive_binary_search(arr, target, 0, len(arr) - 1)
if result != -1:
    print(f"Element found at index {result}")
else:
    print("Element not found")

# Fibonacci number using dynamic programming
def fibonacci(n):
    fib = [0, 1]
    for i in range(2, n + 1):
        fib.append(fib[i - 1] + fib[i - 2])
    return fib[n]
n = int(input("Enter the value of n to find the nth Fibonacci number: "))
result = fibonacci(n)
print(f"The {n}th Fibonacci number is: {result}")

# Krushkal's Algorithm
def kruskal_mst(graph):
    parent = {}
    rank = {}
    def find(node):
        if parent[node] != node:
            parent[node] = find(parent[node])
        return parent[node]
    def union(node1, node2):
        root1 = find(node1)
        root2 = find(node2)
        if root1 != root2:
            if rank[root1] > rank[root2]:
                parent[root2] = root1
            else:
                parent[root1] = root2
                if rank[root1] == rank[root2]:
                    rank[root2] += 1
    for node in graph['vertices']:
        parent[node] = node
        rank[node] = 0
    edges = graph['edges']
    edges = sorted(edges, key=lambda x: x[2])
    minimum_spanning_tree = set()
    for edge in edges:
        node1, node2, weight = edge
        if find(node1) != find(node2):
            union(node1, node2)
            minimum_spanning_tree.add(edge)
    return minimum_spanning_tree
graph = {
    'vertices': ['A', 'B', 'C', 'D', 'E'],
    'edges': [
        ('A', 'B', 2),
        ('A', 'C', 3),
        ('B', 'C', 1),
        ('B', 'D', 1),
        ('C', 'D', 1),
        ('C', 'E', 5),
        ('D', 'E', 4)
    ]
}
mst = kruskal_mst(graph)
print("Minimum Spanning Tree:")
for edge in mst:
    print(edge)

# 4 Queen's problem
def is_safe(board, row, col):
    for i in range(col):
        if board[row][i] == 1:
            return False
    for i, j in zip(range(row, -1, -1), range(col, -1, -1)):
        if board[i][j] == 1:
            return False
    for i, j in zip(range(row, len(board), 1), range(col, -1, -1)):
        if board[i][j] == 1:
            return False
    return True
def solve_queens(board, col):
    if col >= len(board):
        return True
    for i in range(len(board)):
        if is_safe(board, i, col):
            board[i][col] = 1
            if solve_queens(board, col + 1):
                return True
            board[i][col] = 0
    return False
def print_board(board):
    for row in board:
        print(row)
board = [[0 for _ in range(4)] for _ in range(4)]
if solve_queens(board, 0):
    print("Solution found:")
    print_board(board)
else:
    print("No solution found.")

# Adjacency Matrix
class Graph:
    def __init__(self, num_vertices):
        self.num_vertices = num_vertices
        self.adj_matrix = [[0] * num_vertices for _ in range(num_vertices)]
    def add_edge(self, v1, v2):
        if v1 >= 0 and v1 < self.num_vertices and v2 >= 0 and v2 < self.num_vertices:
            self.adj_matrix[v1][v2] = 1
            self.adj_matrix[v2][v1] = 1
    def display_adjacency_matrix(self):
        for row in self.adj_matrix:
            print(row)
graph = Graph(5)
graph.add_edge(0, 1)
graph.add_edge(0, 2)
graph.add_edge(1, 3)
graph.add_edge(2, 4)
print("Adjacency Matrix:")
graph.display_adjacency_matrix()

# Depth First Search
class Graph:
    def __init__(self):
        self.graph = {}
    def add_edge(self, u, v):
        if u in self.graph:
            self.graph[u].append(v)
        else:
            self.graph[u] = [v]
    def dfs(self, start_vertex):
        visited = set()
        stack = [start_vertex]
        result_stack = []
        while stack:
            current_vertex = stack.pop()
            if current_vertex not in visited:
                result_stack.append(current_vertex)
                visited.add(current_vertex)
                if current_vertex in self.graph:
                    for neighbor in reversed(self.graph[current_vertex]):
                        if neighbor not in visited:
                            stack.append(neighbor)
        print("Depth First Traversal in stack form starting from vertex", start_vertex, ":")
        print(result_stack[::-1])
graph = Graph()
graph.add_edge(0, 1)
graph.add_edge(0, 2)
graph.add_edge(1, 2)
graph.add_edge(2, 0)
graph.add_edge(2, 3)
graph.add_edge(3, 3)
graph.dfs(2)

# Breadth First Search
from collections import deque
class Graph:
    def __init__(self):
        self.graph = {}
    def add_edge(self, u, v):
        if u in self.graph:
            self.graph[u].append(v)
        else:
            self.graph[u] = [v]
    def bfs(self, start_vertex):
        visited = set()
        queue = deque([start_vertex])
        visited.add(start_vertex)
        while queue:
            current_vertex = queue.popleft()
            print(current_vertex, end=' ')
            if current_vertex in self.graph:
                for neighbor in self.graph[current_vertex]:
                    if neighbor not in visited:
                        queue.append(neighbor)
                        visited.add(neighbor)
graph = Graph()
graph.add_edge(0, 1)
graph.add_edge(0, 2)
graph.add_edge(1, 2)
graph.add_edge(2, 0)
graph.add_edge(2, 3)
graph.add_edge(3, 3)
print("Breadth First Traversal starting from vertex 2:")
graph.bfs(2)

"""#Algolution"""

#Count total negative numbers
def neg_count(l):
  count = 0
  for i in l:
    if i<0:
        count = count+1
  return count
l = []
n = int(input("Enter number of elements in array: "))
for i in range(n):
  elements = int(input("Enter elements: "))
  l.append(elements)
print(neg_count(l))

# max of all numbers
def max_num(l):
  max_num = l[0]
  for i in l:
    if i>max_num:
      max_num = i
  return max_num
l = []
n = int(input("Enter number of elements: "))
for i in range(n):
  elements = int(input("Enter elements: "))
  l.append(elements)
print(max_num(l))

# Merge two sorted arrays to third array
def merge(l1,l2):
  l3 = []
  i = 0
  j = 0
  while i<len(l2) and j<len(l1):
    if l1[j]<l2[i]:
      l3.append(l1[j])
      j = j+1
    else:
      l3.append(l2[i])
      i = i+1
  return l3
l1 = list(map(int, input("Enter a sorted list of elements separated by spaces: ").split()))
l2 = list(map(int, input("Enter a sorted list of elements separated by spaces: ").split()))
o = []
o = merge(l1,l2)
for i in o:
  print(i)

# 7 integers as input and reverse the order of numbers in array
def reverse(l):
  l.reverse()
  return l
l = []
for i in range(7):
  elements = int(input("Enter elements: "))
  l.append(elements)
l.reverse()
for i in l:
  print(i)

# 5 integers as input and find if order of number is palindrome
def find_order_of_palindrome(l):
  y = l.copy()
  y.reverse()
  if l == y:
    return True
  else:
    return False
l = []
for i in range(4):
  elements = int(input("Enter elements: "))
  l.append(elements)
if find_order_of_palindrome(l):
  print("True")
else:
  print("False")

# search a number in an array and print the index of input
def search(l,m):
  for i in range(len(l)):
    if l[i] == m:
      return i
  return -1
l = []
n = int(input("Enter number in array: "))
for i in range(n):
  elements = int(input("Enter elements: "))
  l.append(elements)
m = int(input("Enter number to search: "))
print(search(l,m))

# print unique numbers in array
def unique(l):
  for i in l:
    if l.count(i) == 1:
      print(i)
l = []
n = int(input("Enter numbers in array: "))
for i in range(n):
  elements = int(input("Enter elements: "))
  l.append(elements)
unique(l)

# count frequency of each number in array
def count_frequency(l):
  f = {}
  for i in l:
    if i in f:
      f[i] = f[i]+1
    else:
      f[i] = 1
  return f
l = []
n = int(input("Enter numbers in array: "))
for i in range(n):
  elements = int(input("Enter elements: "))
  l.append(elements)
print(count_frequency(l))

1# count total duplicate numbers
def total_duplicate(l):
  count = 0
  for i in l:
    if l.count(i)>1:
      count = count+1
  return count
l = []
n = int(input("Enter numbers in array: "))
for i in range(n):
  elements = int(input("Enter elements: "))
  l.append(elements)
print(total_duplicate(l))

# number of rows and column should be input to print parallelogram function
def print_parallelogram(r):
  for i in range(r,0,-1): #3
    for j in range(i-1):
      print(" ",end="")
    for k in range(r):
      print("*",end="")
    print()

r = int(input("Enter number of rows: "))
print_parallelogram(r)
'''
  ***
 ***
***
'''

# print right triange
def print_right_triangle(n):
  for i in range(n):
    for j in range(i+1):
      print("*",end=" ")
    print()
n = int(input("Enter number of rows: "))
print_right_triangle(n)

# print half diamond
def print_half_diamond(n):
  for i in range(1,n+1):
    print("*" *i)
  for j in range(n-1,0,-1):
    print("*" *j)
n = int(input("Enter number of columns: "))
print_half_diamond(n)



# pattern to be printed
12345
54321
12345
54321
12345
def pattern(n):
  for i in range(n):
    for j in range(1,n+1):
      print(j,end="")
    print()
  for i in range(n):
    for j in range(n,0,-1):
      print(j,end="")
    print()
n = int(input("Enter number of rows: "))
pattern(n)

# Subarray with largest sum
def max_subarray_sum(nums):
    max_sum = nums[0]
    current_sum = nums[0]

    for i in range(1, len(nums)):
        current_sum = max(nums[i], current_sum + nums[i])
        max_sum = max(max_sum, current_sum)

    return max_sum

nums = list(map(int, input("Enter the integer array: ").split()))
result = max_subarray_sum(nums)
print("The maximum subarray sum is:", result)

# Count inversions of given array
def merge_and_count_inversions(arr, left, mid, right):
    inv_count = 0

    left_arr = arr[left:mid + 1]
    right_arr = arr[mid + 1:right + 1]

    i = j = 0
    k = left

    while i < len(left_arr) and j < len(right_arr):
        if left_arr[i] <= right_arr[j]:
            arr[k] = left_arr[i]
            i += 1
        else:
            arr[k] = right_arr[j]
            j += 1
            inv_count += (len(left_arr) - i)
        k += 1

    while i < len(left_arr):
        arr[k] = left_arr[i]
        i += 1
        k += 1

    while j < len(right_arr):
        arr[k] = right_arr[j]
        j += 1
        k += 1

    return inv_count

def merge_sort(arr, left, right):
    inv_count = 0

    if left < right:
        mid = (left + right) // 2

        inv_count += merge_sort(arr, left, mid)
        inv_count += merge_sort(arr, mid + 1, right)

        inv_count += merge_and_count_inversions(arr, left, mid, right)

    return inv_count

arr = list(map(int, input("Enter the array elements separated by space: ").split()))
result = merge_sort(arr, 0, len(arr) - 1)
print(result)

# kth largest element in the array
import heapq

def find_kth_largest(nums, k):
    min_heap = []

    for num in nums:
        if len(min_heap) < k:
            heapq.heappush(min_heap, num)
        else:
            if num > min_heap[0]:
                heapq.heappop(min_heap)
                heapq.heappush(min_heap, num)

    return min_heap[0]

nums = list(map(int, input("Enter the numbers in the array separated by spaces: ").split()))
k = int(input("Enter the value of k: "))

result = find_kth_largest(nums, k)
print("The", k, "th largest element in the array is:", result)

# a phase palindrome
def is_palindrome(s):
    def process_string(s):
        alphanumeric_chars = [char.lower() for char in s if char.isalnum()]
        return "".join(alphanumeric_chars)

    processed_s = process_string(s)

    return processed_s == processed_s[::-1]

s = input("Enter a string to check if it is a palindrome: ")

result = is_palindrome(s)
if result:
    print("The input string is a palindrome.")
else:
    print("The input string is not a palindrome.")

# Equilibrium point
def find_equilibrium_index(arr):
    total_sum = sum(arr)
    left_sum = 0

    for i in range(len(arr)):
        total_sum -= arr[i]

        if left_sum == total_sum:
            return i + 1

        left_sum += arr[i]

    return -1

arr = input("Enter the array elements separated by spaces: ")
arr = list(map(int, arr.split()))

equilibrium_index = find_equilibrium_index(arr)

if equilibrium_index != -1:
    print("Equilibrium index is:", equilibrium_index)
else:
    print("No equilibrium index found in the array.")

# Naive Approach:
def find_pair_naive(arr, N, X):
    for i in range(N):
        for j in range(i+1, N):
            if arr[i] + arr[j] == X:
                return "Yes"
    return "No"

N = int(input("Enter the size of the array: "))
A = list(map(int, input("Enter the elements of the array (sorted): ").split()))
X = int(input("Enter the target sum: "))

result_naive = find_pair_naive(A, N, X)
print("Using Naive Approach - Output:", result_naive)

# Two Pointer Technique
def find_pair_two_pointer(arr, N, X):
    left = 0
    right = N - 1

    while left < right:
        current_sum = arr[left] + arr[right]
        if current_sum == X:
            return "Yes"
        elif current_sum < X:
            left += 1
        else:
            right -= 1

    return "No"

N = int(input("Enter the size of the array: "))
A = list(map(int, input("Enter the elements of the array (sorted): ").split()))
X = int(input("Enter the target sum: "))

result_two_pointer = find_pair_two_pointer(A, N, X)
print("Using Two Pointer Technique - Output:", result_two_pointer)

# maximum sum of k
def max_sum_subarray(arr, n, k):
    if k > n:
        return "Invalid"

    max_sum = 0
    window_sum = sum(arr[:k])

    for i in range(n - k):
        window_sum = window_sum - arr[i] + arr[i + k]
        max_sum = max(max_sum, window_sum)

    return max_sum

arr = list(map(int, input("Enter the elements of the array: ").split()))
k = int(input("Enter the value of 'k': "))

n = len(arr)
result = max_sum_subarray(arr, n, k)
print("Output:", result)

# price of stock
def max_profit(prices):
    if not prices:
        return 0

    min_price = prices[0]
    max_profit = 0

    for price in prices:
        min_price = min(min_price, price)
        max_profit = max(max_profit, price - min_price)

    return max_profit

prices = [7, 1, 5, 3, 6, 4]
result = max_profit(prices)
print("Output:", result)

# Hashmap
def max_length_subarray(nums, target):
    max_length = 0
    sum_index_map = {}
    current_sum = 0
    result_subarray = []

    for i in range(len(nums)):
        current_sum += nums[i]

        if current_sum == target:
            max_length = i + 1
            result_subarray = nums[:i+1]

        if current_sum not in sum_index_map:
            sum_index_map[current_sum] = i

        if current_sum - target in sum_index_map:
            if i - sum_index_map[current_sum - target] > max_length:
                max_length = i - sum_index_map[current_sum - target]
                result_subarray = nums[sum_index_map[current_sum - target] + 1:i+1]

    if result_subarray:
        return result_subarray
    else:
        return "No subarray found with the given sum"

nums = [5, 6, -5, 5, 3, 5, 3, -2, 0]
target = 8
result = max_length_subarray(nums, target)
print("Output:", result)

def heapify(arr, n, i, heap_type):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2
    if heap_type == 'min':
        if left < n and arr[left] > arr[largest]:
            largest = left
        if right < n and arr[right] > arr[largest]:
            largest = right
    elif heap_type == 'max':
        if left < n and arr[left] < arr[largest]:
            largest = left
        if right < n and arr[right] < arr[largest]:
            largest = right
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest, heap_type)

def heap_sort(arr, heap_type):
    n = len(arr)
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i, heap_type)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]
        heapify(arr, i, 0, heap_type)
    return arr

A = list(map(int, input("Enter the elements of the array: ").split()))
Max_heap = heap_sort(A.copy(),'max')
Min_heap = heap_sort(A.copy(),'min')
print("Max heap: ",Max_heap)
print("Min heap: ",Min_heap)

#Cyclic palindrome
def head_shift(s):
  return s[1:] + s[0]

def tail_shift(s):
  return s[-1] + s[:-1]

def is_palindrome(s):
  return s == s[::-1]

def is_cyclic_palindrome(s):
  if is_palindrome(s):
    return 0
  n = len(s)
  min_shifts = float('inf')
  for i in range(n):
    head = s[i:] + s[:i]
    if is_palindrome(head):
      min_shifts = min(min_shifts, i)
      break
    tail = s[-i:] + s[:-i]
    if is_palindrome(tail):
      min_shifts = min(min_shifts, i)
      break
  if min_shifts == float('inf'):
    return -1
  else:
    return min_shifts
n = int(input("Enter the number of strings: "))
for i in range(n):
  s = input("Enter a string: ")
  print(is_cyclic_palindrome(s))

# square_free_number
def square_free_number(n):
   def is_square_free(num):
    for i in range(2, int(num**0.5)+1):
      if num % (i*i) == 0:
        return False
    return True
   count = 0
   l = []
   for i in range(2,n+1):
    if n % i == 0 and is_square_free(i):
      l.append(i)
      count = count+1
   return count,l
n = int(input("Enter a number: "))
print(square_free_number(n))

# contiguous subarray
def max_contagious_subarray(A,k):

A = list(map(int, input("Enter the elements of the array: ").split()))
k = int(input("Enter the value of 'k': "))
print(max_contagious_subarray(A,k))